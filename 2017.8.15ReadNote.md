# 8月15号读书笔记

标签（空格分隔）： 未分类

---

BitMap算法
--------

一、算法思想
十进制和二进制bit位需要一个map图，把十进制的数映射到bit位。
二、作用
利用内存中连续的二进制位（bit），用于对大量整型数据做去重和查询
三、解析bitmap表映射关系

假设需要排序或者查找的总数N=10000000，那么我们需要申请内存空间的大小为int a[1 + N/32]，其中：a[0]在内存中占32位可以对应十进制数0-31，

1）bitmap表：

a[0]--------->0-31 
a[1]--------->32-63 
a[2]--------->64-95 
a[3]--------->96-127 

i = 0    ->            00000000000000000000000000000000 
i = 1    ->            00000000000000000000000000000001 
i = 2    ->            00000000000000000000000000000010 
i = 4    ->            00000000000000000000000000000100

2)解析bitmap对应表
a.求十进制0-N对应在数组a中的下标： 
十进制0-31，对应在a[0]中，先由十进制数n转换为与32的余可转化为对应在数组a中的下标。比如n=24,那么n/32=0，则24对应在数组a中的下标为0。又比如n=60,那么n/32=1，则60对应在数组a中的下标为1，同理可以计算0-N在数组a中的下标。

b.求0-N对应0-31中的数： 
十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。

c.利用移位0-31使得对应32bit位为1. 

四、优缺点
1）优点：运算效率高，占用内存少：比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M

2）缺点：所有的数据不能重复。不支持非运算，原因：比如一个长度是10的bitmap  0000000100B，代表使用苹果手机的用户，同时全量数据只有2个用户。这时候取非的结果是1111111011B，即9个用户，和实际情况（不适用苹果手机的用户有1个）不符。除非所有用户ID完全连续，且用户总量和bitmap长度一致。

五、实例
需求：
为了精准定位用户群体，需要开发一个用户画像系统，实现用户信息标签化，用户标签包括社会属性、生活习惯、消费行为等等主要信息。通过用户标签，可以实现多样的用户群体统计，比如统计用户的男女比例，统计喜欢旅游的用户数量等等。

数据表设计：
a.先建立一个用户名和用户ID的映射
b.让每一个标签存储包含此标签的所有用户ID，每一个标签都是一个独立的Bitmap
这样就能实现用户的去重和查询统计

## bitmap算法进阶 ##
一、实现非运算
    给一个特定的bitmap，例如，给定90后用户的一个bitmap，再给定一个全量用户的bitmap，最终要求出的是存在于全量用户，但又不是存在于90后用户的部分。
    可以使用异或操作！！！这种情况下计算获得的结果和非运算的结果相同。
二、空间问题的解决
    问题描述：一个很长的bitmap里只存有一两个用户。
    解决方法：把bitmap存储于long数组当中
    详解：
        long数组的每一个元素都可以当成是64位的二进制数，也就是bitmap的子集（谷歌把这些子集叫做Word）。
        当创建一个空的bitmap时，初始只有4个Word，也即long数组的长度是4，Word的数量会随着数据的不断插入而逐渐扩充。在还未插入任何数据的时候，所有的Word值都是0.其中Word0是不直接存储数据的，暂时可以认为它存储的是bitmap的头信息。
        
            Word0：00000000B    （？？？）
            Word1：00000000B    （0L）
            Word2：00000000B    （0L）
            Word3：00000000B    （0L）
            
        现在插入一个ID为1的用户，由于Word0不直接存储数据，所以是插入到Word1中，结果如下：
            Word0：00000000B    （？？？）
            Word1：00000010B    （2L）最右边的二进制位代表ID=0
            Word2：00000000B    （0L）
            Word3：00000000B    （0L）
            
        再插入ID=4的用户，结果如下：
        
            Word0：00000000B    （？？？）
            Word1：00010010B    （18L）
            Word2：00000000B    （0L）
            Word3：00000000B    （0L）
            
        再插入ID是64的新用户，由于Word1存储范围只有0-63，因此64会存入到Word2中，结果如下：
        
            Word0：00000000B    （？？？）
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000000B    （0L）
            
        在插入一个ID是129的用户，由于前两个Word最大可以存储到127，因此129应当存入到Word3中，结果如下：
        
            Word0：00000000B    （？？？）
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000010B    （2L）
            
        这个时候，所有的Word都已经被占用，bitmap此时会进行动态扩充，结果如下：
        
            Word0：00000000B    （？？？）
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000010B    （2L）
            Word4：00000000B    （0L）
            Word5：00000000B    （0L）
            Word6：00000000B    （0L）
            Word7：00000000B    （0L）
            
        如果要插入一个ID为400000的用户，bitmap会改变后方两个Word，Word4变成一个特殊的Word————Running Length Word（RLW），直接存储数据的叫Literal Word（LW）。其中Word0和Word4就属于RLW
        RLW：每一个RLW都分成两部分，低32位表示当前Word横跨多少个空Word，高32位表示当前RLW后方有多少个连续的LW。
        
            Word0：00000000B    后方有3个连续LW，自身横跨0个Word
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000010B    （2L）
            Word4：00000000B   （？？？） 后方有1个连续的LW，自身横跨6247个Word
            Word5：00000001B    （0L）
            Word6：00000000B    （0L）
            Word7：00000000B    （0L）
            
        （400000+1）/64商6250余1，所以这个Word本身值为1L，前面有6250个Word。
        
        对于极端稀疏的bitmap，这是一个很好的解决办法！
        
        由于bitmap里有些Word属于RLW————含有跨度信息的Word，当新插入数据时，就要依靠RLW作为路标。
        插入ID=400003，结果如下：
        
            Word0：00000000B    后方有3个连续LW，自身横跨0个Word
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000010B    （2L）
            Word4：00000000B   （？？？） 后方有1个连续的LW，自身横跨6247个Word
            Word5：00000001B    （0L）
            Word6：00000000B    （0L）
            Word7：00000000B    （0L）
        
        解析过程如下：
            1、解析Word0，得知当前RLW横跨的空Word数量为0，后面有连续的3个LW
            2、计算当前RLW后方连续普通Word的最大ID是64*（0+3）-1=191.
            3、由于191<400003，所以新ID必然在下一个RLW（Word4）之后
            4、解析Word4，得知当前RLW横跨的空Word数量为6247，后面有连续一个LW。
            5、计算出当前RLW（Word4）后方连续LW的最大ID是191+（6247+1）*64=400063
            6、由于400003<400063,因此新ID=400003的正确位置就在当前RLW（Word4）之后，即Word5中
            
            如果插入的新ID刚好在存储横跨信息的RLW范围内，例如：200000，这种情况会涉及原RLW的分裂，结果如下：
        
            Word0：00000000B    后方有3个连续LW，自身横跨0个Word
            Word1：00010010B    （18L）
            Word2：00000001B    （1L）
            Word3：00000010B    （2L）
            Word4：00000000B   （？？？） 后方有1个连续的LW，自身横跨3122个Word
            Word5：00000000B    （0L）--->ID=200000
            Word6：00000000B   （？？？） 后方有1个连续的LW，自身横跨3124个Word
            Word7：00000001B    （0L）
            Word8：00000000B    （0L）
            Word9：00000000B    （0L）
        
        在RLW中间插入数值的时候，会涉及到部分的Word移位，影响，所以谷歌官方建议使用者从小到大插入数据。