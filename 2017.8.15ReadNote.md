# 8月15号读书笔记

标签（空格分隔）： 未分类

---

BitMap算法
--------

一、算法思想
十进制和二进制bit位需要一个map图，把十进制的数映射到bit位。
二、作用
利用内存中连续的二进制位（bit），用于对大量整型数据做去重和查询
三、解析bitmap表映射关系

假设需要排序或者查找的总数N=10000000，那么我们需要申请内存空间的大小为int a[1 + N/32]，其中：a[0]在内存中占32位可以对应十进制数0-31，

1）bitmap表：

a[0]--------->0-31 
a[1]--------->32-63 
a[2]--------->64-95 
a[3]--------->96-127 

i = 0    ->            00000000000000000000000000000000 
i = 1    ->            00000000000000000000000000000001 
i = 2    ->            00000000000000000000000000000010 
i = 4    ->            00000000000000000000000000000100

2)解析bitmap对应表
a.求十进制0-N对应在数组a中的下标： 
十进制0-31，对应在a[0]中，先由十进制数n转换为与32的余可转化为对应在数组a中的下标。比如n=24,那么n/32=0，则24对应在数组a中的下标为0。又比如n=60,那么n/32=1，则60对应在数组a中的下标为1，同理可以计算0-N在数组a中的下标。

b.求0-N对应0-31中的数： 
十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。

c.利用移位0-31使得对应32bit位为1. 

四、优缺点
1）优点：运算效率高，占用内存少：比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M

2）缺点：所有的数据不能重复。不支持非运算，原因：比如一个长度是10的bitmap  0000000100B，代表使用苹果手机的用户，同时全量数据只有2个用户。这时候取非的结果是1111111011B，即9个用户，和实际情况（不适用苹果手机的用户有1个）不符。除非所有用户ID完全连续，且用户总量和bitmap长度一致。

五、实例
需求：
为了精准定位用户群体，需要开发一个用户画像系统，实现用户信息标签化，用户标签包括社会属性、生活习惯、消费行为等等主要信息。通过用户标签，可以实现多样的用户群体统计，比如统计用户的男女比例，统计喜欢旅游的用户数量等等。

数据表设计：
a.先建立一个用户名和用户ID的映射
b.让每一个标签存储包含此标签的所有用户ID，每一个标签都是一个独立的Bitmap
这样就能实现用户的去重和查询统计

代码实现bitmap：

    class Bitmap 
    {
        private $handler = NULL;  
        private $max = 0;  
        public function __construct($file)   
        {  
            clearstatcache(true, $file);      
            if(file_exists($file))  
                $this->handler = @fopen($file , 'r+') OR die('open bitmap file failed');  
            else  
                $this->handler = @fopen($file , 'w+') OR die('open bitmap file failed');  
            $this->max = file_exists($file) ? (filesize($file) * 8 - 1) : 0;  
        }  
        public function __destruct()   
        {  
            @fclose($this->handler);  
        }      
    }

    
    
    
    
    
    
    

