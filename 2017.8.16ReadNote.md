# 8月16号读书笔记

标签（空格分隔）： 未分类

---

js精度问题
------

js数字丢失精度的原因：

首先我们要知道，JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。存储时，1位用来表示符号位 11位用来表示指数 52位表示尾数。

其次计算机的二进制实现和位数会限制有些数字无法有限表示，比如一些无理数就不能有限表示，π=3.141592653......

浮点数，比如：0.1 >> 0.0001 1001 1001 1001…（1001无限循环）0.2 >> 0.0011 0011 0011 0011…（0011无限循环）
此时只能模仿十进制进行四舍五入了，但是二进制只有0和1两个，于是变为 0舍1入，计算机在部分浮点数的运算中出现误差，这是js丢失精度的根本原因。

大整数的精度丢失和浮点数本质上是一样的，尾数位最大是52位，因此 JS 中能精准表示的最大整数是Math.pow(2, 53)，十进制即9007199254740992。

所以大于 9007199254740992 的可能会丢失精度

9007199254740992 === 9007199254740992 + 1  (true)
9007199254740992 === 9007199254740992 + 2  (false)


详解：
9007199254740992  >> 10000000000000...000 // 共计 53 个 0

9007199254740992 + 1 >> 10000000000000...001 //中间 52 个 0  (丢失) 9007199254740992 + 2 >> 10000000000000...010 //中间 51 个 0  (未丢失)

同理可得：
9007199254740992 === 9007199254740992 + 3  (true)
9007199254740992 === 9007199254740992 + 4  (false)


